<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="author" content="Nicolai Søborg">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Badger, badger, badger, mushroom, mushroom! &mdash; badger2.søb.org &#8480;</title>
	<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
	<![endif]-->
	<style type="text/css">
		#container { width: 100%; overflow: hidden; }
		#menu {
			background-color: #EEEEDD; border: 1px solid #CCC; border-radius: 3px; position: fixed;
			width: 200px; padding: 5px; margin-top: 1em; }
		#badgeContainer { display: table-cell; position: absolute; margin-left: 220px /*menu width + padding, etc*/; }
		.badge { float: left; }
		.draggable { cursor: move; }
		.closeBtn { float: right; position: relative; right: 25px; top: 25px; }
		.hidden { display: none; }
		@media print { .no-print, .no-print * { display: none !important; } }
	</style>

	<!-- Extra fonts -->
	<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Clicker+Script|Diplomata+SC|Griffy|Indie+Flower|Kaushan+Script|Lobster|Orbitron|Permanent+Marker|Poiret+One|Roboto|Satisfy" rel="stylesheet">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js" integrity="sha384-/EjRuG6YTb6zCFou+DBnYCi5u9E1RjUMJanyGOL7DUYLp6wSCUuHNhd58uoGj7jh" crossorigin="anonymous"></script> 
</head>
<body>
<div id="container">
	<span class="no-print">
		<strong>Badger!</strong>
		<a href="#" data-bind="click: cloneBadge">clone badge</a><input id="shareBg" type="checkbox" checked="checked" title="If checked, then new (cloned) badges will share the same background image" />,
		<a href="#" data-bind="click: saveBadges">save badges</a>, <a href="#" data-bind="click: loadBadges">load badges</a>,
		<a href="#" id="togglePrint" data-bind="click: togglePrint">prepare print</a>
	</span>
	<br />
	<div id="menu" data-bind="visible: showMenu()" class="no-print">Click any element on the badge to change content. &rarr;<br />
	<strong>Tip:</strong> double-click inside the badge (not on the text) to change background.</div>

	<!-- Define globale styles for badges
	Every elm. with a non-unique "id" attribute should be listed below -->
	<svg version="1.1" width="0" height="0" xmlns="http://www.w3.org/2000/svg">
		<defs>
			<clipPath id="badge-cutoff">
				<circle data-bind="attr: $root.badges()[0].circle" r="2.5cm"></circle>
			</clipPath>
			<clipPath id="badge-full">
				<circle data-bind="attr: $root.badges()[0].circle" r="3.05cm"></circle>
			</clipPath>
		</defs>
	</svg>

	<!-- Create badges -->
	<div data-bind="foreach: badges" id="badgeContainer">
		<div data-bind="attr: {badgeId: _id}" class="badge">
			<button class="closeBtn no-print" data-bind="visible: $root.showMenu, click: $root.deleteBadge.bind()" title="Delete badge">X</button>
			<svg version="1.1" baseProfile="full" width="300" height="300" xmlns="http://www.w3.org/2000/svg">
				<defs>
					<path data-bind="attr: {id: 'upper-path' + _id, d: upper_attr.d}"></path>
					<path data-bind="attr: {id: 'lower-path' + _id, d: lower_attr.d}"></path>
				</defs>

				<!-- 'Actual' badge (when designing): -->
				<image data-bind="attr: img, visible: $root.showMenu" clip-path="url(#badge-cutoff)"></image>
				<!-- Actual badge (when printing): -->
				<image data-bind="attr: img, visible: !$root.showMenu()" clip-path="url(#badge-full)"></image>
				<!-- Badge background: -->
				<image data-bind="attr: img, visible: $root.showMenu, event: { mousedown: beginMove, mousemove: doMove, mouseup: stopMove }" style="opacity: 0.2" class="draggable no-print"></image>

				<!-- The outermost circle (always visible): -->
				<circle data-bind="attr: circle, click: $root.ondblclickFix.bind()" ondblclick="viewModel.changeBackground(this.parentElement.parentElement.attributes.badgeId.value)" r="3.05cm" stroke-width="0.1mm" stroke-dasharray="5,5" fill="transparent"></circle>

				<text>
					<textPath data-bind="attr: upper_attr" onclick="viewModel.editBadge(this)">Harebo '16</textPath>
					<textPath data-bind="attr: lower_attr" onclick="viewModel.editBadge(this)">C. Software</textPath>
				</text>
				<text data-bind="attr: middle_attr" onclick="viewModel.editBadge(this)">Søborg</text>
			</svg>
			<br />
			<input type="file" accept="image/*" data-bind="attr: {id: 'fileSelect' + _id}" class="hidden" />
			<span class="no-print" data-bind="visible: $root.showMenu">
				Scale: <input type="range" min="0.1" max="5" step="0.1" data-bind="value: imgScale"/>
			</span>
		</div>
	</div><!--/foreach badges-->
</div>
<script type="text/javascript">
"use strict";
let badgeCounter = 0,
	viewModel = null; // needed to be defined before imgScale
const FONTS = ["Times New Roman", "Helvetica", "Arial", "Comic Sans MS", "Segoe Print", "Terminal", "Impact", "Tahoma", "Wingdings",
	"Griffy", "Roboto", "Diplomata SC", "Indie Flower", "Lobster", "Amatic SC", "Clicker Script", "Orbitron", "Poiret One", "Satisfy", "Kaushan Script", "Permanent Marker"];

let Badge = function(badgeId) {
	let obj = {
		_id: badgeId,
		upper_attr: {
			d: "M 80, 150 c 0, -100, 140, -100, 140, 0",
			href: "#upper-path" + badgeId,
			textContent: "Harebo '16",
			startOffset: "50%",
		},
		middle_attr: {
			textContent: "Søborg",
			x: 150,
			y: 175,
		},
		lower_attr: {
			d: "M 60, 150 c 0, 120, 180, 120, 180, 0",
			href: "#lower-path" + badgeId,
			textContent: "C. Software",
			startOffset: "50%",
		},
		circle: {
			cx: 150,
			cy: 150,
			stroke: "black",
		},
		imgScale: ko.computed({
			read: function() { return 1; },
			write: function(value) {
				viewModel.badges().forEach(function(badge) {
					if (badge._id == badgeId) {
						badge.img.height( 400 * value );
						badge.img.width( 400 * value );
					}
				});
			}
		}),
		img: {
			href: ko.observable("picture_bg.jpg"),
			x: ko.observable(-50),
			y: ko.observable(-50),
			height: ko.observable(400),
			width: ko.observable(400),
		},
		mouseCoord: {x: 0, y: 0}, // "private" holder for mouse movement
		isMouseMoving: false,
		beginMove: function(_, event) {
			this.mouseCoord.x = event.clientX;
			this.mouseCoord.y = event.clientY;
			this.isMouseMoving = true;
		},
		doMove: function(_, event) {
			if (this.isMouseMoving) {
				let diffX = event.clientX - this.mouseCoord.x,
					diffY = event.clientY - this.mouseCoord.y;
				this.img.x(this.img.x() + diffX);
				this.img.y(this.img.y() + diffY);
				// Reset mouse coords:
				this.mouseCoord.x = event.clientX;
				this.mouseCoord.y = event.clientY;
			}
		},
		stopMove: function() {
			this.isMouseMoving = false;
		}
	};
	// Please fix this:
	obj.upper_attr["font-size"] = 25;
	obj.lower_attr["font-size"] = 25;
	obj.middle_attr["font-size"] = 60;
	for (let attr of [obj.upper_attr, obj.middle_attr, obj.lower_attr]) {
		attr["fill"] = "#FFFFFF"; // white
		attr["text-anchor"] = "middle";
		attr["font-family"] = "Tahoma";
	};
	return obj;
}

viewModel = {
	badges: ko.observableArray([ new Badge(badgeCounter) ]),
	showMenu: ko.observable(true),
	cloneBadge: function() {
		let badge = new Badge(++badgeCounter);

		let stdBadge = this.badges()[0], // clone properties from the first badge
			dontClone = ["_id", "imgScale", "beginMove", "doMove", "stopMove"];
		
		// If 'img' is cloned, then the badges will share the same background image:
		if (!document.getElementById("shareBg").checked) dontClone.push("img");

		for (let key in stdBadge) {
			if (stdBadge.hasOwnProperty(key) // http://stackoverflow.com/a/559002
				&& dontClone.indexOf(key) == -1) { 
					badge[key] = stdBadge[key];
			}
		}

		// Push to beginning of array:
		this.badges.unshift(badge);
		this.textContentFix(badgeCounter);
	},
	deleteBadge: function(badge) {
		if (viewModel.badges().length == 1) {
			document.getElementById("menu").innerHTML = "Can't delete the last badge!";
			return;
		}
		viewModel.badges().forEach(function(b) {
			if (b._id == badge._id) {
				viewModel.badges.remove(b);
			}
		});
	},
	editBadge: function(elm) {
		let attr = elm.attributes;
		let menu = document.getElementById("menu");
		let disabledElms = ["onclick", "data-bind", "href", "d", "text-anchor"];

		// delete old menu:
		menu.innerHTML = "<center><strong>MENU</strong></center>";

		for (let i = 0; i < attr.length; i++) {
			let elmName = attr[i].name,
				elmVal = attr[i].value;

			// Skip stuff user shouldn't change
			// For some reason elmName is uppercase in IE, but lowercase elsewhere:
			if (disabledElms.indexOf(elmName.toLowerCase()) > -1)
				continue;

			// Create an input form for changing value
			let label = document.createElement("LABEL");
			label.setAttribute("for", elmName);
			label.textContent = elmName + ": ";

			let input = document.createElement("INPUT");
			if (elmName == "font-family") {
				input = document.createElement("SELECT");
				for (let font of FONTS) {
					let opt = document.createElement("OPTION");
					opt.text = font;
					opt.style.fontFamily = font;
					opt.setAttribute("value", font);
					if (font == elmVal)
						opt.setAttribute("selected", true);

					input.appendChild(opt);
				}
			} else {
				input.setAttribute("value", elmVal);
			}

			input.setAttribute("name", elmName);
			let valType = elmVal[0] == "#" ? "color" : (!isNaN(elmVal) && elmVal !== "") ? "number" : "string";
			input.setAttribute("type", valType);
			input.style.width = "100%";

			// Make sure to userinput will update visible design:
			for (let fuckJS of ["onchange", "onkeydown", "onpaste", "oninput"]) {
				input[fuckJS] = function() {
					if (this.name == "textContent") {
						elm.textContent = this.value;
						// Make sure "deleted" textfields still can be selected:
						if (elm.textContent == "")
							elm.innerHTML = "&nbsp;&nbsp;";
					}

					// TODO: This seems a bit hacky:
					// I can't remember what the idea is, but it seems to work:
					let self = this;
					let attr_name = attr["data-bind"].value.replace("attr: ", "");
					viewModel.badges().forEach(function(badge) {
						badge[attr_name][self.name] = self.value;
						//console.log("Updating badges["+attr_name+"]["+self.name+"] = " + self.value);
					});

					// Update HTML:
					attr[this.name].value = this.value;
				}
			}

			// Append 'input line' to menu:
			menu.appendChild(label);
			menu.appendChild(input);
			menu.appendChild(document.createElement("BR"));
		}

		menu.appendChild(document.createElement("BR"));
	},
	saveBadges: function() {
		let textarea = document.createElement("textarea");
		textarea.textContent = ko.toJSON(viewModel);
		textarea.onclick = function() { this.select() };
		menu.innerHTML = "Save this text somewhere:<br>";
		document.getElementById("menu").appendChild(textarea);
	},
	loadBadges: function() {
		let textarea = document.createElement("textarea"); textarea.id = "loadtxt";
		let btn = document.createElement("button"); btn.textContent = "Load";
		btn.onclick = function() {
			document.getElementById("shareBg").checked = false;
			let json = JSON.parse(document.getElementById("loadtxt").value);
			while (viewModel.badges().length > 1)
				viewModel.badges.pop();
			for (let i = 0; i < json["badges"].length; i++) {
				let badgeProps = json["badges"][i];
				
				let badge = new Badge(badgeProps._id);
				let dontClone = ["_id" ,"mouseCoord", "isMouseMoving"];
				for (let prop in badgeProps) {
					if (dontClone.indexOf(prop) !== -1) continue;

					badge[prop] = badgeProps[prop];
				}
				viewModel.badges.unshift(badge);
				viewModel.textContentFix(badgeProps._id);
				console.log("Adding badge " + badgeProps._id);
			}
			viewModel.badges.pop();
		}
		//textarea.textContent = ko.toJSON(viewModel);
		menu.innerHTML = "Paste loaded badges:<br>";
		document.getElementById("menu").appendChild(textarea);
		document.getElementById("menu").appendChild(document.createElement("br"));
		document.getElementById("menu").appendChild(btn);
	},
	togglePrint: function() {
		let showMenu = this.showMenu();

		// Update text:
		document.getElementById("togglePrint").textContent = showMenu ? "show menu" : "prepare print";

		// Update CSS (remove menu span):
		document.getElementById("badgeContainer").style.position = showMenu ? "relative" : "absolute";

		// Toggle value:
		this.showMenu(!showMenu);
	},
	changeBackground: function(badgeId) {
		this.badges().forEach(function(badge) {
			if (badge._id == badgeId) {
				let f = document.getElementById("fileSelect" + badgeId);
				f.onchange = function(){
					let reader = new FileReader();
					// What to do when loading of data is done:
					reader.onload = function(event) {
						badge.img.href(event.target.result);
					}
					// Begin loading data (async)
					reader.readAsDataURL(this.files[0]);
				};
				f.click(); // activate "select file" diag
			}
		});
	},
	ondblclickFix: function(badge, event) {
		// 'ondblclick' isn't actually defined on svg elements,
		// but just happens to work in Chrome and IE, but not FF.
		// Link: https://bugzilla.mozilla.org/show_bug.cgi?id=360145
		if (navigator.userAgent.indexOf("Firefox") > -1
			&& event.detail >= 2) {
			viewModel.changeBackground(badge._id);
		}
	},
	textContentFix: function(badgeId) {
		let walkDOM = function (node,func) {
			func(node);
			node = node.firstChild;
			while(node) {
				walkDOM(node,func);
				node = node.nextSibling;
			}
		}
		for (let badge of document.getElementsByClassName("badge")) {
			if (badge.attributes["badgeid"].value != badgeId)
				continue;
			
			// Fix mismatches between textContent and innerHTML:
			walkDOM(badge, function(node) {
				if (typeof node.attributes === "object" && "textContent" in node.attributes)
					node.innerHTML = "" + node.attributes.textContent.value;
			});
		}
	}
};

ko.applyBindings(viewModel);
</script>
</body>
</html>
