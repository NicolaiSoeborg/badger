<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="author" content="Nicolai Søborg">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Badger, badger, badger, mushroom, mushroom! &mdash; badger.søb.org &#8480;</title>
	<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
	<![endif]-->
	<style type="text/css">
		#container { width: 100%; overflow: hidden; }
		#menu {
			background-color: #EEEEDD; border: 1px solid #CCC; border-radius: 3px; position: fixed;
			width: 200px; padding: 5px; margin-top: 1em; }
		#badgeContainer { display: table-cell; position: absolute; margin-left: 220px /*menu width + padding, etc*/; }
		.vLine { border-left: solid black; padding-left: 0.5ch; }
		.badge { float: left; }
		.draggable { cursor: move; }
		.closeBtn { float: right; position: relative; right: 25px; top: 25px; }
		.hidden { display: none; }
		@media print {
			.no-print, .no-print * { display: none !important; }
			.at-print, .at-print * { display: block !important; }
		}
	</style>

	<!-- Extra fonts -->
	<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Clicker+Script|Diplomata+SC|Griffy|Indie+Flower|Kaushan+Script|Lobster|Orbitron|Permanent+Marker|Poiret+One|Roboto|Satisfy" rel="stylesheet">

	<!-- Knockout.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js" integrity="sha384-/EjRuG6YTb6zCFou+DBnYCi5u9E1RjUMJanyGOL7DUYLp6wSCUuHNhd58uoGj7jh" crossorigin="anonymous"></script> 

	<!-- Intro.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/2.7.0/intro.min.js" integrity="sha384-HC7wl1tJhn6CACy4tkgl7ISUgjsE8/AoG+RwdYiYPwT7gtb4QdnCN+bdCEIqELO0" crossorigin="anonymous"></script>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/2.7.0/introjs.min.css" rel="stylesheet">
</head>
<body>
<div id="container">
	<h1 id="warningBanner" class="hidden at-print">YOU FORGOT TO PRESS 'prepare print'</h1>
	<span class="no-print" data-bind="visible: showMenu()">
		<strong>Badger!</strong>
		<span id="clone">
			<a href="#" data-bind="click: cloneBadge">clone badge</a>
			<input id="shareBg" type="checkbox" checked="checked" title="If checked, then new (cloned) badges will share the same background image (you probably want this to be checked)." />
		</span>
		<a href="#" class="vLine" data-bind="click: saveBadges">save badges</a><sup><small>BETA</small></sup>
		<a href="#" class="vLine" data-bind="click: loadBadges">load badges</a>
		<a href="#" class="vLine" onclick="startIntro()">help</a>
	</span>
	<a href="#" id="togglePrint" class="vLine no-print" data-bind="click: togglePrint">prepare print</a>
	<br />
	<div id="menu" data-bind="visible: showMenu()" class="no-print">Click any element on the badge to change content. &rarr;<br />
	<strong>Tip:</strong> double-click <em>inside</em> the badge (not on the text) to change background image.</div>

	<!-- Define globale styles for badges
	Every elm. with a non-unique "id" attribute should be listed below -->
	<svg version="1.1" width="0" height="0" xmlns="http://www.w3.org/2000/svg">
		<defs>
			<clipPath id="badge-cutoff">
				<circle data-bind="attr: $root.badges()[0].circle" r="2.5cm"></circle>
			</clipPath>
			<clipPath id="badge-full">
				<circle data-bind="attr: $root.badges()[0].circle" r="3.1cm"></circle>
			</clipPath>
		</defs>
	</svg>

	<!-- Create badges -->
	<div data-bind="foreach: badges" id="badgeContainer">
		<div data-bind="attr: {badgeid: _id}" class="badge"><!-- contenteditable="true" -->
			<button class="closeBtn no-print" data-bind="visible: $root.showMenu, click: $root.deleteBadge.bind()" title="Delete badge">X</button>
			<svg version="1.1" baseProfile="full" width="300" height="300" xmlns="http://www.w3.org/2000/svg">
				<defs>
					<path data-bind="attr: {id: 'upper-path' + _id, d: upper_attr.d}"></path>
					<path data-bind="attr: {id: 'lower-path' + _id, d: lower_attr.d}"></path>
				</defs>

				<!-- 'Actual' badge (when designing): -->
				<image data-bind="attr: img, visible: $root.showMenu" clip-path="url(#badge-cutoff)"></image>
				<!-- Actual badge (when printing): -->
				<image data-bind="attr: img, visible: !$root.showMenu()" clip-path="url(#badge-full)"></image>
				<!-- Badge background: -->
				<image data-bind="attr: img, visible: $root.showMenu, event: { mousedown: beginMove, mousemove: doMove, mouseup: stopMove }" style="opacity: 0.2" class="draggable no-print"></image>

				<!-- The outermost circle (always visible): -->
				<circle data-bind="attr: circle, click: $root.ondblclickFix.bind()" ondblclick="viewModel.changeBackground(this.parentElement.parentElement.attributes.badgeid.value)" r="3.1cm" stroke-width="0.1mm" stroke-dasharray="5,5" fill="transparent"></circle>

				<text>
					<textPath attrname="upper_attr" data-bind="attr: upper_attr" onclick="viewModel.editBadge(this)">Harebo '16</textPath>
					<textPath attrname="lower_attr" data-bind="attr: lower_attr" onclick="viewModel.editBadge(this)">C. Software</textPath>
				</text>
				<text attrname="middle_attr" data-bind="attr: middle_attr" onclick="viewModel.editBadge(this)">Søborg</text>
			</svg>
			<br />
			<input type="file" accept="image/*" data-bind="attr: {id: 'fileSelect' + _id}" class="hidden" />
			<span class="no-print" data-bind="visible: $root.showMenu, attr: {id: 'imgSlider' + _id}" contenteditable="false">
				Scale: <input type="range" min="0.01" max="5" step="0.01" data-bind="value: imgScale, valueUpdate: 'input'"/>
			</span>
		</div>
	</div><!--/foreach badges-->
</div>
<script type="text/javascript">
if (/Trident/.test(navigator.userAgent)) {
	alert("Internet Explorer isn't supported.\nPlease use any other browser.");
}
</script>
<script type="text/javascript">
"use strict";

// Constants and global variables:
let badgeCounter = 0,
	viewModel = null; // needed to be defined before imgScale
const FONTS = ["Times New Roman", "Helvetica", "Arial", "Comic Sans MS", "Segoe Print",
			"Terminal", "Impact", "Tahoma", "Wingdings", "Griffy", "Roboto", "Diplomata SC",
			"Indie Flower", "Lobster", "Amatic SC", "Clicker Script", "Orbitron", "Poiret One",
			"Satisfy", "Kaushan Script", "Permanent Marker"],
	isColor = new RegExp("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");

const Badge = function(badgeId) {
	let obj = {
		_id: badgeId,
		upper_attr: {
			d: "M 80, 150 c 0, -100, 140, -100, 140, 0",
			href: "#upper-path" + badgeId,
			textContent: "Harebo '16",
			startOffset: "50%",
		},
		middle_attr: {
			textContent: "Søborg",
			x: 150,
			y: 175,
		},
		lower_attr: {
			d: "M 60, 150 c 0, 120, 180, 120, 180, 0",
			href: "#lower-path" + badgeId,
			textContent: "C. Software",
			startOffset: "50%",
		},
		circle: {
			cx: 150,
			cy: 150,
			stroke: "black",
			backgroundColor: "#FFFFFF", // white background
		},
		imgScale: ko.computed({
			read: function() { return 1; },
			write: function(value) {
				viewModel.badges().forEach(function(badge) {
					if (badge._id == badgeId) {
						const newSize = 400 * value;
						// Make sure the image zooms in on the middle, and not down-right:
						badge.img.x( badge.img.x() + (badge.img.width() - newSize)/2 );
						badge.img.y( badge.img.y() + (badge.img.height() - newSize)/2 );
						// The scale image:
						badge.img.width(newSize);
						badge.img.height(newSize);
					}
				});
			}
		}),
		img: {
			href: ko.observable("picture_bg.jpg"),
			x: ko.observable(-50),
			y: ko.observable(-50),
			height: ko.observable(400),
			width: ko.observable(400),
		},
		mouse: {
			moving: false,
			x: 0,
			y: 0,
		},
		beginMove: function(_, event) {
			this.mouse.x = event.clientX;
			this.mouse.y = event.clientY;
			this.mouse.moving = true;
		},
		doMove: function(_, event) {
			if (this.mouse.moving) {
				const diffX = event.clientX - this.mouse.x,
					diffY = event.clientY - this.mouse.y;
				this.img.x(this.img.x() + diffX);
				this.img.y(this.img.y() + diffY);
				// Reset mouse coords:
				this.mouse.x = event.clientX;
				this.mouse.y = event.clientY;
			}
		},
		stopMove: function() {
			this.mouse.moving = false;
		}
	};
	// Please fix this:
	obj.upper_attr["font-size"] = 25;
	obj.lower_attr["font-size"] = 25;
	obj.middle_attr["font-size"] = 60;
	for (let attr of [obj.upper_attr, obj.middle_attr, obj.lower_attr]) {
		attr["fill"] = "#FFFFFF"; // white text
		attr["text-anchor"] = "middle";
		attr["font-family"] = "Tahoma";
	}
	return obj;
};

viewModel = {
	badges: ko.observableArray([ new Badge(badgeCounter) ]),
	showMenu: ko.observable(true),
	cloneBadge: function() {
		let badge = new Badge(++badgeCounter);

		let stdBadge = this.badges()[0], // clone properties from the first badge
			dontClone = ["_id", "imgScale", "beginMove", "doMove", "stopMove", "mouse"];
		
		// If 'img' is cloned, then the badges will share the same background image:
		if (!document.getElementById("shareBg").checked)
			dontClone.push("img");

		for (let key in stdBadge) {
			if (stdBadge.hasOwnProperty(key) // http://stackoverflow.com/a/559002
				&& dontClone.indexOf(key) == -1) { 
					badge[key] = stdBadge[key];
			}
		}

		// Push to beginning of array (KO.js will create html):
		this.badges.unshift(badge);

		// Fix mismatch between innerHTML and textContent / viewModel:
		this.textContentFix(badgeCounter);

		// Remove extra image scale slider, if needed:
		if (document.getElementById("shareBg").checked) {
			const imgSlider = document.getElementById("imgSlider" + badgeCounter);
			imgSlider.parentElement.removeChild(imgSlider);
		}

		// Set 'menu focus' on new badge:
		// TODO: This will automatic select middle_text
		document.getElementsByClassName("badge")[0].children[1].children[6].onclick();
	},
	deleteBadge: function(badge) {
		if (viewModel.badges().length == 1) {
			document.getElementById("menu").innerHTML = "Can't delete the last badge!<br>Press F5 to reset layout.";
			return;
		}
		viewModel.badges().forEach(function(b) {
			if (b._id == badge._id) {
				viewModel.badges.remove(b);
			}
		});
	},
	editBadge: function(elm) {
		// 'elm' is an element inside the badge, lets first find the badgeid:
		let badgeId = 0;
		let bgColor;
		for (var e2 = elm; e2 !== null; e2 = e2.parentElement) {
			if (e2.attributes.hasOwnProperty("badgeid")) {
				badgeId = e2.attributes.badgeid.value;
				bgColor = e2.style.backgroundColor;
				break;
			}
		}

		// Create fake 'background color attribute'
		if (!isColor.test(bgColor)) {
			bgColor = '#' + bgColor
								.split("(")[1].split(")")[0]
								.split(",")
								.map(function(x) {
									x = parseInt(x).toString(16);
									return (x.length==1) ? "0" + x : x;
								})
								.join('');
		}
		elm.setAttribute("backgroundColor", bgColor);

		let attr = elm.attributes;
		let menu = document.getElementById("menu");

		// Reset (delete) old menu:
		menu.innerHTML = "<center><strong>MENU</strong></center>";

		// Don't allow the user to change these attributes:
		let disabledElms = ["onclick", "data-bind", "href", "d", "text-anchor", "attrname"];

		for (let i = 0; i < attr.length; i++) {
			let elmName = attr[i].name,
				elmVal = attr[i].value;

			// For some reason elmName is uppercase in IE, but lowercase elsewhere:
			if (disabledElms.indexOf(elmName.toLowerCase()) > -1)
				continue;

			// Create an input form for changing value:
			let label = document.createElement("LABEL");
			label.setAttribute("for", elmName);
			label.textContent = (elmName == "textContent" ? "text" : elmName) + ":";

			let input = document.createElement("INPUT");
			if (elmName == "font-family") {
				input = document.createElement("SELECT");
				for (let font of FONTS) {
					let opt = document.createElement("OPTION");
					opt.text = font;
					opt.style.fontFamily = font;
					opt.setAttribute("value", font);
					if (font == elmVal)
						opt.setAttribute("selected", true);
					input.appendChild(opt);
				}
			} else {
				input.setAttribute("value", elmVal);
			}
			input.setAttribute("name", elmName);
			input.style.width = "100%";

			let valType = isColor.test(elmVal) ? "color" : (!isNaN(elmVal) && elmVal !== "") ? "number" : "string";
			input.setAttribute("type", valType);

			// Make sure any input will update visible design:
			for (const fuckJS of ["onchange", "onkeydown", "onpaste", "oninput"]) {
				input[fuckJS] = function() {
					if (this.name == "textContent") {
						elm.textContent = this.value;
						// Make sure "deleted" textfields still can be selected:
						if (elm.textContent == "")
							elm.innerHTML = "&nbsp;&nbsp;";
					}

					let self = this;
					viewModel.badges().forEach(function(badge) {
						if (badge._id == badgeId) {
							let prop = attr["attrname"].value; // [lower|middle|upper]_attr

							if (elmName == 'backgroundColor')
								prop = 'circle';

							badge[prop][self.name] = self.value;
							console.log("Updating badges["+badgeId+"]["+prop+"]["+self.name+"] = " + self.value);
						}
					});

					if (elmName != 'backgroundColor') {
						// Update HTML. TODO: this shouldn't be needed (but it doesn't work without...)
						attr[elmName].value = this.value;
					}
				};
			}

			// Append 'input line' to menu:
			menu.appendChild(label);
			menu.appendChild(input);
			menu.appendChild(document.createElement("BR"));
		} // Done adding dynamic items.

		menu.appendChild(document.createElement("BR"));

		// Set focus AND MOVE CURSOR TO LAST POSITION
		// ... yes this is really ugly, because Chrome: https://stackoverflow.com/a/10576409
		let textInput = document.getElementsByName("textContent")[0];
		if (textInput.addEventListener) {
			textInput.addEventListener("focus", function() {
				setTimeout(function(){ textInput.selectionStart = textInput.selectionEnd = 10000; }, 0);
			}, false);
		}
		textInput.focus();
	},
	saveBadges: function() {
		let textarea = document.createElement("TEXTAREA"),
			menu = document.getElementById("menu");
		textarea.textContent = ko.toJSON(viewModel);
		textarea.onclick = function() { this.select(); };  // TODO: why doesn't this work anymore?
		menu.innerHTML = "Save this text somewhere:<BR>";
		menu.appendChild(textarea);
		menu.innerHTML += "<BR><strong>WARNING:</strong> the text is very long and this feature is a bit buggy! Try not to rely on it. When your design is finished, use <strong>menu &rarr; print &rarr; save to file</strong>";
	},
	loadBadges: function() {
		let menu = document.getElementById("menu");
		let textarea = document.createElement("TEXTAREA"); textarea.id = "loadtxt";
		let btn = document.createElement("BUTTON"); btn.textContent = "Load";
		btn.onclick = function() {
			document.getElementById("shareBg").checked = false;
			let json;
			try {
				json = JSON.parse(document.getElementById("loadtxt").value);
			} catch(e) {
				const msg = "Can't load badges!";
				menu.innerHTML += "<BR>" + msg;
				console.log(msg, e);
				return;
			}

			// Delete everything, but the last badge (or else we will lose the template)
			while (viewModel.badges().length > 1)
				viewModel.badges.pop();

			for (let i = 0; i < json["badges"].length; i++) {
				let badgeProps = json["badges"][i];

				let badge = new Badge(badgeProps._id);
				let dontClone = ["_id", "mouse"];
				for (let prop in badgeProps) {
					if (dontClone.indexOf(prop) !== -1) continue;

					badge[prop] = badgeProps[prop];
				}
				viewModel.badges.unshift(badge);
				viewModel.textContentFix(badgeProps._id);
			}

			// Fix badge counter:
			viewModel.badgeCounter = json["badges"].length;

			// Now we can delete the 'last badge' (from before):
			viewModel.badges.pop();

			// Select first badge (changes to 'edit menu'):
			document.getElementsByClassName("badge")[0].children[1].children[6].onclick();
		};
		//textarea.textContent = ko.toJSON(viewModel);
		menu.innerHTML = "Paste saved badges:<br>";
		menu.appendChild(textarea);
		menu.appendChild(document.createElement("BR"));
		menu.appendChild(btn);
	},
	togglePrint: function() {
		let showMenu = this.showMenu();

		// Update text:
		document.getElementById("togglePrint").textContent = showMenu ? "show menu" : "prepare print";

		// Update CSS (remove menu span):
		document.getElementById("badgeContainer").style.position = showMenu ? "relative" : "absolute";

		// Hide warning banner:
		if (showMenu)
			document.getElementById("warningBanner").classList.remove('at-print');
		else
			document.getElementById("warningBanner").classList.add('at-print');

		// Toggle value:
		this.showMenu(!showMenu);
	},
	changeBackground: function(badgeId) {
		this.badges().forEach(function(badge) {
			if (badge._id == badgeId) {
				let f = document.getElementById("fileSelect" + badgeId);
				f.onchange = function(){
					let reader = new FileReader();
					// What to do when loading of data is done:
					reader.onload = function(event) {
						badge.img.href(event.target.result);
					};
					// Begin loading data (async)
					reader.readAsDataURL(this.files[0]);
				};
				f.click(); // activate "select file" diag
			}
		});
	},
	ondblclickFix: function(badge, event) {
		// 'ondblclick' isn't actually defined on svg elements,
		// but just happens to work in Chrome and IE, but not FF.
		// Link: https://bugzilla.mozilla.org/show_bug.cgi?id=360145
		if (navigator.userAgent.indexOf("Firefox") > -1
			&& event.detail >= 2) {
			viewModel.changeBackground(badge._id);
		}
	},
	textContentFix: function(badgeId) {
		let walkDOM = function (node,func) {
			func(node);
			node = node.firstChild;
			while(node) {
				walkDOM(node,func);
				node = node.nextSibling;
			}
		};
		for (let badge of document.getElementsByClassName("badge")) {
			if (badge.attributes["badgeid"].value != badgeId)
				continue;

			// Fix mismatches between textContent and innerHTML:
			walkDOM(badge, function(node) {
				if (typeof node.attributes === "object" && "textContent" in node.attributes) {
					node.innerHTML = node.attributes.textContent.value;
				}
			});
		}
	}
};

ko.applyBindings(viewModel);

const startIntro = function () {
	const intro = introJs();
	intro.setOptions({
		showStepNumbers: false,
		showProgress: false,
		showBullets: false,
		skipLabel: "Exit",
		steps: [
			{
				intro: "This is the current badge design. The innermost circle is the visible part of the badge, the outermost circle is the 'wrap around' part of the badge.",
				element: document.getElementsByClassName("draggable")[0]
			},
			/*{
				intro: "To change background image, double click inside the badge circle (not on the text). Protip: make sure to select a image without too much 'noice' or the text might be hard to see on the print.",
				element: document.getElementsByClassName("draggable")[0]
			}*/
			{
				intro: "When the badge design is done, use this button to clone the current badge. If the checkbox is checked, then moving/scaling the background image on one badge will also move/scale the background image on the other badges.",
				element: document.getElementById("clone")
			},
			{
				intro: "When everything is done, click this button and select 'browser menu &rarr; print' (not Ctrl + P). Make sure the webpage isn't zoomed and the printer setting is set to print A4.",
				element: document.getElementById("togglePrint")
			},
			{
				intro: "Happy badging!  Please report any errors/feedback to: <a href='mailto:badger@xn--sb-lka.org'>badger@søb.org</a>"
			}
		]
	});
	intro.start();
};

// Run guide once, when DOM is ready:
document.addEventListener("DOMContentLoaded", function(event) {
	if (!localStorage.getItem("runOnce")) {
		localStorage.setItem("runOnce", true);
		startIntro();
	}
});

</script>
</body>
</html>
