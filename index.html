<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="author" content="Nicolai Søborg">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Badger, badger, badger, mushroom, mushroom! &mdash; badger.søb.org &#8480;</title>
	<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
	<![endif]-->
	<style type="text/css">
		#container { width: 100%; overflow: hidden; }
		#menu {
			background-color: #EEEEDD; border: 1px solid #CCC; border-radius: 3px; position: fixed;
			width: 200px; padding: 5px; margin-top: 1em; }
		#badgeContainer { display: table-cell; position: absolute; margin-left: 220px /*menu width + padding, etc*/; }
		.vLine { border-left: solid black; padding-left: 0.5ch; }
		.badge { float: left; }
		.draggable { cursor: move; }
		.closeBtn { float: right; position: relative; right: 25px; top: 25px; }
		.hidden { display: none; }
		@media print {
			.no-print, .no-print * { display: none !important; }
			.at-print, .at-print * { display: block !important; }
		}
	</style>

	<!-- Extra fonts -->
	<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Clicker+Script|Diplomata+SC|Griffy|Indie+Flower|Kaushan+Script|Lobster|Orbitron|Permanent+Marker|Poiret+One|Roboto|Satisfy" rel="stylesheet">

	<!-- Knockout.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js" integrity="sha384-/EjRuG6YTb6zCFou+DBnYCi5u9E1RjUMJanyGOL7DUYLp6wSCUuHNhd58uoGj7jh" crossorigin="anonymous"></script> 

	<!-- Intro.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/2.7.0/intro.min.js" integrity="sha384-HC7wl1tJhn6CACy4tkgl7ISUgjsE8/AoG+RwdYiYPwT7gtb4QdnCN+bdCEIqELO0" crossorigin="anonymous"></script>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/2.7.0/introjs.min.css" rel="stylesheet">
</head>
<body>
<div id="container">
	<h1 id="warningBanner" class="hidden at-print">You forgot to press 'prepare print'</h1>
	<span class="no-print" data-bind="visible: showMenu">
		<strong>Badger!</strong>
		<span id="clone">
			<a href="#" data-bind="click: cloneBadge">clone badge</a>
			<input id="shareBg" type="checkbox" checked="checked" title="If checked, then new (cloned) badges will share the same background image (you probably want this to be checked)." />
		</span>
		<a href="#" class="vLine" data-bind="click: saveBadges">save badges</a><sup><small>BETA</small></sup>
		<a href="#" class="vLine" data-bind="click: loadBadges">load badges</a>
		<a href="#" class="vLine" onclick="startIntro()">help</a>
	</span>
	<a href="#" id="togglePrint" class="vLine no-print" data-bind="click: togglePrint">prepare print</a>
	<span data-bind="visible: showMenu" class="no-print" style="float: right;">
		<a href="#" data-bind="click: function () { this.showChangelog(!this.showChangelog()); }">Changelog</a> (v2.1.X)
		<div data-bind="visible: showChangelog">
			<p>[v1.x] Idea by <a href="https://github.com/henrikh">Henrik Enggaard</a>.</p>
			<p>[v2.0.0] Rebuild using knockout.js</p>
			<p>[v2.1.0] Added 'add more text' and custom fonts</p>
			<p>[v2.1.1] Fix 'upper + lower text' when deleting initial badge</p>
			<p>[v2.1.2] Fix change background image in Firefox</p>
			<p></p>
		</div>
	</span>
	<br />
	<div id="menu" data-bind="visible: showMenu" class="no-print">Click any element on the badge to change content. &rarr;<br />
	<strong>Tip:</strong> double-click <em>inside</em> the badge (not on the text) to change background image.</div>

	<!-- Define globale styles for badges
	Every elm. with a non-unique "id" attribute should be listed below -->
	<svg version="1.1" width="0" height="0" xmlns="http://www.w3.org/2000/svg">
		<defs>
			<clipPath id="badge-cutoff">
				<circle data-bind="attr: $root.badges()[0].circle" r="2.5cm"></circle>
			</clipPath>
			<clipPath id="badge-full">
				<circle data-bind="attr: $root.badges()[0].circle" r="3.1cm"></circle>
			</clipPath>
		</defs>
	</svg>

	<!-- Msg box that can be used for messages (hidden by default) -->
	<dialog id="msgDiag" class="no-print" open onclick=" this.removeAttribute('open') ">
		<a href="#" style="float: right;" title="Click to close dialog">X</a>
		<p id="msg">[EMPTY]</p>
	</dialog>

	<!-- Create badges -->
	<div data-bind="foreach: badges" id="badgeContainer">
		<div data-bind="attr: {badgeid: _id}" class="badge"><!-- contenteditable="true" -->
			<button class="closeBtn no-print" data-bind="visible: $root.showMenu, click: $root.deleteBadge" title="Delete badge">X</button>
			<svg version="1.1" baseProfile="full" width="300" height="300" xmlns="http://www.w3.org/2000/svg">
				<defs>
					<path data-bind="attr: {id: 'upper-path' + _id, d: upper_attr.d}"></path>
					<path data-bind="attr: {id: 'lower-path' + _id, d: lower_attr.d}"></path>
				</defs>

				<!-- 'Actual' badge (when designing): -->
				<image data-bind="attr: img, visible: $root.showMenu" clip-path="url(#badge-cutoff)"></image>
				<!-- Full badge (when printing): -->
				<image data-bind="attr: img, visible: !$root.showMenu()" clip-path="url(#badge-full)"></image>
				<!-- Badge background image: -->
				<image data-bind="attr: img, visible: $root.showMenu, event: { mousedown: beginMove, mousemove: doMove, mouseup: stopMove }" style="opacity: 0.2" class="draggable no-print"></image>

				<!-- The outermost circle (always visible): -->
				<circle data-bind="attr: circle, click: function(data, event) { viewModel.changeBackground(event, _id) }, event: { mousedown: beginMove, mousemove: doMove, mouseup: stopMove }" r="3.1cm" stroke-width="0.1mm" stroke-dasharray="5,5" fill="transparent" class="draggable"></circle>

				<text>
					<textPath attrname="upper_attr" data-bind="attr: upper_attr" onclick="viewModel.editBadge(this)">Harebo '16</textPath>
					<!--<textPath data-bind="attr: upper_attr, click: $root.editBadge.bind(this, _id, 'upper_attr'), clickBubble: false">Harebo '16</textPath>-->

					<textPath attrname="lower_attr" data-bind="attr: lower_attr" onclick="viewModel.editBadge(this)">C. Software</textPath>
					<!--<textPath data-bind="attr: lower_attr, click: $root.editBadge.bind(this, _id, 'lower_attr'), clickBubble: false">C. Software</textPath>-->
				</text>
				<text>
					<tspan attrname="middle_attr1" data-bind="attr: middle_attr1" onclick="viewModel.editBadge(this)">Søborg</tspan>
					<tspan attrname="middle_attr2" data-bind="attr: middle_attr2, visible: show_middle2" onclick="viewModel.editBadge(this)">[more text]</tspan>
					<!--<tspan data-bind="attr: middle_attr1, click: $root.editBadge.bind(this, _id, 'middle_attr1'), clickBubble: false">Langt</tspan>
					<tspan data-bind="attr: middle_attr2, click: $root.editBadge.bind(this, _id, 'middle_attr2'), clickBubble: false">navn</tspan>-->
				</text>
			</svg>
			<br />
			<input type="file" accept="image/*" data-bind="attr: {id: 'fileSelect' + _id}" class="hidden" />
			<span class="no-print" data-bind="visible: $root.showMenu, attr: {id: 'imgSlider' + _id}" contenteditable="false">
				Scale: <input type="range" min="0.01" max="5" step="0.01" data-bind="value: imgScale, valueUpdate: 'input'"/>
			</span>
		</div>
	</div><!--/foreach badges-->
</div>
<script type="text/javascript">
if (/Trident/.test(navigator.userAgent)) {
	alert("Internet Explorer isn't supported.\nPlease use any other browser.");
}
</script>
<script type="text/javascript">
"use strict";

// Constants and global variables:
let badgeCounter = 0,
    fonts = ["Times New Roman", "Helvetica", "Arial", "Comic Sans MS", "Segoe Print",
		"Terminal", "Impact", "Tahoma", "Wingdings", "Griffy", "Roboto", "Diplomata SC",
		"Indie Flower", "Lobster", "Amatic SC", "Clicker Script", "Orbitron", "Poiret One",
		"Satisfy", "Kaushan Script", "Permanent Marker", "[Add new font]"],
	viewModel = null; // need to be defined before imgScale

const isColor = new RegExp("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");

const Badge = function(badgeId) {
	//console.log(`Creating new badge with id=${badgeId}`);
	let obj = {
		_id: badgeId,
		upper_attr: {
			d: "M 80, 150 c 0, -100, 140, -100, 140, 0",
			href: "#upper-path" + badgeId,
			textContent: "Harebo '16",
			startOffset: "50%",
		},
		middle_attr1: {
			textContent: "Søborg",
			x: 150,
			y: 175,
		},
		show_middle2: ko.observable(false),
		middle_attr2: {
			textContent: "[more text]",
			x: 150,
			dy: 50,
		},
		lower_attr: {
			d: "M 60, 150 c 0, 120, 180, 120, 180, 0",
			href: "#lower-path" + badgeId,
			textContent: "C. Software",
			startOffset: "50%",
		},
		circle: {
			cx: 150,
			cy: 150,
			stroke: "black",
		},
		imgScale: ko.computed({
			read: function() { return 1; },
			write: function(value) {
				viewModel.badges().forEach(function(badge) {
					if (badge._id == badgeId) {
						const newSize = 400 * value;
						// Make sure the image zooms in on the middle, and not down-right:
						badge.img.x( badge.img.x() + (badge.img.width() - newSize)/2 );
						badge.img.y( badge.img.y() + (badge.img.height() - newSize)/2 );
						// Then scale image:
						badge.img.width(newSize);
						badge.img.height(newSize);
					}
				});
			}
		}),
		img: {
			href: ko.observable("picture_bg.jpg"),
			x: ko.observable(-50),
			y: ko.observable(-50),
			height: ko.observable(400),
			width: ko.observable(400),
		},
		mouse: {
			moving: false,
			x: 0,
			y: 0,
		},
		beginMove: function(_, event) {
			this.mouse.x = event.clientX;
			this.mouse.y = event.clientY;
			this.mouse.moving = true;
		},
		doMove: function(_, event) {
			if (this.mouse.moving) {
				const diffX = event.clientX - this.mouse.x,
					diffY = event.clientY - this.mouse.y;
				this.img.x(this.img.x() + diffX);
				this.img.y(this.img.y() + diffY);
				// Reset mouse coords:
				this.mouse.x = event.clientX;
				this.mouse.y = event.clientY;
			}
		},
		stopMove: function() {
			this.mouse.moving = false;
		}
	};
	// Please fix this:
	obj.upper_attr["font-size"] = 25;
	obj.lower_attr["font-size"] = 25;
	obj.middle_attr1["font-size"] = 50;
	obj.middle_attr2["font-size"] = 50;
	for (let attr of [obj.upper_attr, obj.middle_attr1, obj.middle_attr2, obj.lower_attr]) {
		attr["fill"] = "#FFFFFF"; // white text
		attr["text-anchor"] = "middle";
		attr["font-family"] = "Tahoma";
	}
	return obj;
};

// Helpers:
const showMsg = function(msg) {
	const elm = document.getElementById("msg"),
		diag = document.getElementById("msgDiag");
	if (typeof(msg) === 'string') {
		elm.textContent = msg;
	} else {
		elm.appendChild(msg);
	}
	diag.setAttribute('open', 'true');
}
const elmBuilder = function(/*string*/type, child) {
	const elm = document.createElement(type);
	if (typeof(child) === "string") {
		elm.textContent = child;
	} else {
		elm.appendChild(child);
	}
	return elm;
}

viewModel = {
	badges: ko.observableArray([ new Badge(badgeCounter) ]),
	getBadge: function(badgeId) {
		let foundBadge;
		this.badges().forEach(function (badge) {
			if (badge._id == badgeId) {
				foundBadge = badge;
			}
		});
		return foundBadge;
	},
	showMenu: ko.observable(true),
	showChangelog: ko.observable(false),
	cloneBadge: function() {
		let badge = new Badge(++badgeCounter);

		let stdBadge = this.badges()[0], // clone properties from the first badge
			dontClone = ["_id", "imgScale", "beginMove", "doMove", "stopMove", "mouse"];
		
		// If 'img' is cloned, then the badges will share the same background image:
		if (!document.getElementById("shareBg").checked)
			dontClone.push("img");

		for (let key in stdBadge) {
			if (stdBadge.hasOwnProperty(key) // http://stackoverflow.com/a/559002
				&& dontClone.indexOf(key) == -1) { 
					badge[key] = stdBadge[key];
			}
		}
		// Fix wrong 'href' is wrong on cloned badges:
		badge.upper_attr.href = "#upper-path" + badgeCounter;
		badge.lower_attr.href = "#lower-path" + badgeCounter;

		// Push to beginning of array (KO.js will create html):
		this.badges.unshift(badge);

		// Fix mismatch between innerHTML and textContent / viewModel:
		this.textContentFix(badgeCounter);

		// Remove extra image scale slider, if needed:
		if (document.getElementById("shareBg").checked) {
			const imgSlider = document.getElementById("imgSlider" + badgeCounter);
			imgSlider.parentElement.removeChild(imgSlider);
		}
	},
	deleteBadge: function(badge) {
		if (viewModel.badges().length == 1) {
			showMsg("Can't delete the last badge!\nPress F5 to reset layout.");
			return;
		}
		console.log(`Deleting badge ${JSON.stringify(badge)}`);
		viewModel.badges.remove(badge);
	},
	editBadge: function(elm) {
		const menu = document.getElementById("menu"),
			// Don't allow the user to (see &)change these attributes:
			disabledElms = ["d", "href", "text-anchor", "style", "onclick", "data-bind", "attrname"],
			attr = elm.attributes;

		// Reset (delete) old menu:
		menu.innerHTML = "<center><strong>MENU</strong></center>";

		let badgeId = 0;
		for (var e2 = elm; e2 !== null; e2 = e2.parentElement) {
			if (e2.attributes.hasOwnProperty("badgeid")) {
				badgeId = e2.attributes.badgeid.value;
				break;
			}
		}

		//for (const [elmName, elmVal] of Object.entries(badge[attr_name])) {
		for (let i = 0; i < attr.length; i++) {
			const elmName = attr[i].name,
				elmVal = attr[i].value;

			// For some reason elmName is uppercase in IE, but lowercase elsewhere:
			if (disabledElms.indexOf(elmName.toLowerCase()) > -1)
				continue;

			// Create an input form for changing value:
			const label = document.createElement("LABEL");
			label.setAttribute("for", elmName);
			label.textContent = `${elmName == 'textContent' ? 'text' : elmName}:`;

			let input = document.createElement("INPUT");
			if (elmName == "font-family") {
				input = document.createElement("SELECT");
				input.setAttribute("id", "fonts");
				// All predefined fonts:
				for (const font of fonts) {
					const opt = document.createElement("OPTION");
					opt.text = font;
					opt.style.fontFamily = font;  // doesn't work in Firefox :|
					opt.setAttribute("value", font);
					if (font == elmVal)
						opt.setAttribute("selected", true);
					input.appendChild(opt);
				}
			} else {
				input.setAttribute("value", elmVal);
			}
			input.setAttribute("name", elmName);
			input.style.width = "90%";

			let valType = isColor.test(elmVal) ? "color" : (!isNaN(elmVal) && elmVal !== "") ? "number" : "string";
			input.setAttribute("type", valType);

			// Make sure any input will update visible design:
			for (const fuckJS of ["onchange", "onkeydown", "onpaste", "oninput"]) {
				input[fuckJS] = function() {
					// Special cases:
					if (this.name === "textContent") {
						// Set text value:
						elm.textContent = this.value;

						// Make sure "deleted" textfields still can be selected:
						if (elm.textContent == "")
							elm.innerHTML = "&nbsp;&nbsp;";
					} else if (this.name === "font-family") {
						// "New font" selected?
						if (this.value === fonts[fonts.length-1]) {
							const fontName = prompt("Font name:"),
								selector = document.getElementById("fonts"),
								fontElm = document.createElement("OPTION");
							if (/.+/.test(fontName)) {
								fontElm.text = fontName;
								fontElm.style.fontFamily = fontName;  // doesn't work in Firefox :|
								fontElm.setAttribute("value", fontName);
								fontElm.setAttribute("selected", true);
								selector.appendChild(fontElm);
							}
						}
					}

					let self = this;
					viewModel.badges().forEach(function(badge) {
						if (badge._id == badgeId) {
							let prop = attr["attrname"].value; // [lower|middle|upper]_attr

							//if (elmName === 'backgroundColor')
							//	prop = 'circle';

							badge[prop][self.name] = self.value;
						}
					});

					// Update HTML. TODO: this shouldn't be needed (but it doesn't work without...)
					// Probably because elms isn't observable?
					attr[elmName].value = this.value;
				}
			}
			// Append all of it to the menu:
			menu.appendChild(label);
			menu.appendChild(document.createElement("BR"));
			menu.appendChild(input);
			menu.appendChild(document.createElement("HR"));
		};
		// ^ Done adding dynamic items.

		// Add "ADVANCED" menu:
		const detailsElm = document.createElement("DETAILS"),
			summaryElm = document.createElement("SUMMARY");
		summaryElm.textContent = "ADVANCED";
		detailsElm.appendChild(summaryElm);

		// Extra text field:
		const extralabel = document.createElement("SPAN"),
			extratxt = document.createElement("INPUT");
		extratxt.setAttribute("type", "checkbox");
		extralabel.textContent = "Add extra text field: ";
		extratxt.checked = viewModel.getBadge(badgeId)['show_middle2']();
		extratxt.onclick = function () {
			viewModel.getBadge(badgeId)['show_middle2'](this.checked);
		}
		extralabel.appendChild(extratxt);
		detailsElm.appendChild(extralabel);
		detailsElm.appendChild(document.createElement("BR"));

		// detailsElm

		menu.appendChild(detailsElm);
		// ^ Done adding one-time items.

		// Set focus AND MOVE CURSOR TO LAST POSITION
		// ... yes this is really ugly, because of Chrome: https://stackoverflow.com/a/10576409
		let textInput = document.getElementsByName("textContent")[0];
		if (textInput && textInput.addEventListener) {
			textInput.addEventListener("focus", function() {
				setTimeout(function(){ textInput.selectionStart = textInput.selectionEnd = 10000; }, 0);
			}, false);
			textInput.focus();
		}
	},
	saveBadges: function() {
		let textarea = document.createElement("TEXTAREA"),
			menu = document.getElementById("menu");
		textarea.textContent = ko.toJSON(viewModel);
		textarea.readOnly = true;
		textarea.onclick = function() {
			this.select();
		};
		menu.innerHTML = "<strong>WARNING:</strong> the text below is very long and this feature is a bit buggy! Try not to rely on it. When your design is finished and all badges has been made, use <strong>menu &rarr; print &rarr; save to file (pdf)</strong><BR/>... or save this long text:";
		menu.appendChild(textarea);
		// This *should work* but will break the onclick function (tested in Firefox v62):
		//menu.innerHTML += "<BR/><strong>WARNING:</strong> the text is very long and this feature is a bit buggy! Try not to rely on it. When your design is finished, use <strong>menu &rarr; print &rarr; save to file</strong>";

	},
	loadBadges: function() {
		let menu = document.getElementById("menu");
		let textarea = document.createElement("TEXTAREA"); textarea.id = "loadtxt";
		let btn = document.createElement("BUTTON"); btn.textContent = "Load";
		btn.onclick = function() {
			document.getElementById("shareBg").checked = false;
			let json;
			try {
				json = JSON.parse(document.getElementById("loadtxt").value);
			} catch(e) {
				const msg = "Can't load badges!";
				menu.innerHTML += "<BR/>" + msg;
				console.log(msg, e);
				return;
			}

			// Delete everything, but the last badge (or else we will lose the template)
			while (viewModel.badges().length > 1)
				viewModel.badges.pop();

			const dontClone = ["_id", "mouse"];
			for (let i = 0; i < json["badges"].length; i++) {
				const badgeProps = json["badges"][i];
				const badge = new Badge(badgeProps._id);

				for (let prop in badgeProps) {
					if (badgeProps.hasOwnProperty(prop)  // http://stackoverflow.com/a/559002
						&& dontClone.indexOf(prop) !== -1)
							continue;

					badge[prop] = badgeProps[prop];
				}
				viewModel.badges.unshift(badge);
				viewModel.textContentFix(badgeProps._id);
			}

			// Fix badge counter:
			viewModel.badgeCounter = json["badges"].length;

			// Now we can delete the 'last badge' (from before):
			viewModel.badges.pop();
		};
		menu.innerHTML = "Paste saved badges:<BR/>";
		menu.appendChild(textarea);
		menu.appendChild(document.createElement("BR"));
		menu.appendChild(btn);
	},
	togglePrint: function() {
		const showMenu = this.showMenu();

		// Update text:
		document.getElementById("togglePrint").textContent = showMenu ? "show menu" : "prepare print";

		// Update CSS (remove menu span):
		document.getElementById("badgeContainer").style.position = showMenu ? "relative" : "absolute";

		// Hide warning banner:
		document.getElementById("warningBanner").classList = "hidden" + (showMenu ? "" : " at-print");

		// Toggle value:
		this.showMenu(!showMenu);
	},
	changeBackground: function(event, badgeId) {
		// 'ondblclick' isn't actually defined on svg elements,
		// but just happens to work in Chrome and IE, but not FF.
		// Link: https://bugzilla.mozilla.org/show_bug.cgi?id=360145
		// So lets not rely on it, and just catch 'two clicks at once' (aka event.detail > 1)
		if (event.detail >= 2) {
			const badge = viewModel.getBadge(badgeId),
				f = document.getElementById("fileSelect" + badgeId);
			f.onchange = function() {
				const reader = new FileReader();
				// What to do when loading of data is done:
				reader.onload = function(event) {
					const data = event.target.result;
					if (data.slice(5, data.indexOf(';')) === 'image/gif') {
						showMsg("WARNING: gifs might print weirdly");
					}
					badge.img.href(data);
				};
				// Begin loading data (async)
				reader.readAsDataURL(this.files[0]);
			};
			f.click(); // activate "select file" diag
		}
	},
	textContentFix: function(badgeId) {
		let walkDOM = function (node, func) {
			func(node);
			node = node.firstChild;
			while(node) {
				walkDOM(node, func);
				node = node.nextSibling;
			}
		};
		// Example:
		//   <ELM textContent="A">B</ELM>
		for (let badge of document.getElementsByClassName("badge")) {
			if (badge.attributes["badgeid"].value != badgeId)
				continue;

			// Fix mismatches between textContent and innerHTML:
			walkDOM(badge, function(node) {
				if (typeof node.attributes === "object" && "textContent" in node.attributes) {
					if (node.innerHTML != node.attributes.textContent.value) {
						console.log(`Fixing badge ${badgeId}: Setting ${node.innerHTML} = ${node.attributes.textContent.value}`);
						node.innerHTML = node.attributes.textContent.value;
						if (node.textContent === "") node.innerHTML = "&nbsp;&nbsp;";
					}
				}
			});
		}
	}
};

ko.applyBindings(viewModel);

const startIntro = function () {
	const intro = introJs();
	intro.setOptions({
		showStepNumbers: false,
		showProgress: false,
		showBullets: false,
		skipLabel: "Exit",
		steps: [
			{
				intro: "This is the current badge design. The innermost circle is the visible part of the badge, the outermost circle is the 'wrap around' part of the badge.",
				element: document.getElementsByClassName("draggable")[0]
			},
			/*{
				intro: "To change background image, double click inside the badge circle (not on the text). Protip: make sure to select a image without too much 'noice' or the text might be hard to see on the print.",
				element: document.getElementsByClassName("draggable")[0]
			}*/
			/*{
				intro: "If you need additional fonts, you can install them on your computer and need to type the exact name of the font.",
				element: document.getElementById("fonts")
			},*/
			{
				intro: "When the badge design is done, use this button to clone the current badge. If the checkbox is checked, then moving/scaling the background image on one badge will also move/scale the background image on the other badges.",
				element: document.getElementById("clone")
			},
			{
				intro: "When everything is done, click this button and select 'menu &rarr; print' (not Ctrl + P). Make sure the webpage isn't zoomed in, and that the printer setting is set to A4.",
				element: document.getElementById("togglePrint")
			},
			{
				intro: "Happy badging!  Please report any errors/feedback to Nicolai Søborg" // <a href='mailto:badger@xn--sb-lka.org'>badger@søb.org</a>
			}
		]
	});
	intro.start();
};

// Run guide once, when DOM is ready:
document.addEventListener("DOMContentLoaded", function(event) {
	if (!localStorage.getItem("runOnce")) {
		localStorage.setItem("runOnce", true);
		startIntro();
	}
});

</script>
</body>
</html>
